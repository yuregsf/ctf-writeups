import hashlib
import base64
from ecdsa.numbertheory import inverse_mod

def H(msg):
    return int(hashlib.sha256(msg.encode()).hexdigest(), 16)

r1=185715843513600925054973553903190743447927171676192310910138858676610263644
s1=82693820656484922896848904048672271969711094268582218440916487771902518219835
r2=185715843513600925054973553903190743447927171676192310910138858676610263644
s2=27686856471548878638709441470538809236274137854596236422571433594729032993082
pub=0x935f240ca927cb5c5b5501ed6db25146dd10c49850ac16dcfee57878c7580c54d805d7475298bd4b25458b458babbb26882af7e24d6c52efbb50db1bba087f1
csecret = "0b556c417508766c716d5f6d750b637f7d7f5f4b79637676754163635f7376744f0b630b6a506f43486e760c7d7e6d7102506a"
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141


M1 =  "6BIYFjS95yhaGs9PREUlS6V2jD160NgwEMCcfUnejg"
M2 =  "8BKOGc3GVhaGs9PREUlhEwDEMCcfUnejgw1Vge60QB"

h1 = H(M1)
h2 = H(M2)
priv = ((s2 * h1 - s1 * h2) * inverse_mod(r1 * (s1 - s2), N)) % N
br = bytearray.fromhex(csecret)
secret = "".join([ chr(b ^ (priv & 0xFF)) for b in br])
secret = secret[::-1]

print(base64.b64decode(secret + '=').decode())
